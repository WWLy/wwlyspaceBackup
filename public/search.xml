<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[协程]]></title>
      <url>%2F2016%2F11%2F24%2F%E5%8D%8F%E7%A8%8B%2F</url>
      <content type="text"><![CDATA[123456789101112131415161718192021222324# -*- coding: utf8 -*-# 消费者def consumer(): r = "" while True: n = yield r if not n: return print("[CONSUMER] Consuming %s..." % n) r = "200 OK"# 生产者def produce(c): c.send(None) n = 0 while n &lt; 5: n = n + 1 print("[PRODUCER] Producing %s..." % n) r = c.send(n) print("[PRODUCER] Consumer return: %s" % r) c.close()c = consumer() produce(c) 每当执行send()函数的时候会来到consumer中yield的下一条语句每当执行到yield时会停住执行produce中send的下一条语句 1234567891011121314def countdown(n): print("Counting down from %d" % n) while n &gt;= 0: newValue = yield n if newValue is not None: n = newValue else: n -= 1c = countdown(5)for x in c: print(x) if x == 5: c.send(3) 输出结果: 5 2 1 0 send给generator的value会成为当前yield的结果 且send的返回结果是下一个yield的结果, 即此处c.send(3)会返回3]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[利用aiohttp搭建python服务器]]></title>
      <url>%2F2016%2F11%2F23%2Faiohttp%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
      <content type="text"><![CDATA[利用aiohttp搭建python服务器123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960# -*- coding: utf8 -*-import logging; logging.basicConfig(level=logging.INFO)import asyncio, os, json, timefrom datetime import datetimefrom aiohttp import webshockRecord = ""wwlyRecord = ""result = ""def index(request): global shockRecord global wwlyRecord global result text = '%s' % request.match_info['anything'] # print(text) if 'shock:' in text: tempShock = text[6:] shockRecord = shockRecord + "&lt;/br&gt;" + tempShock elif 'wwly:' in text: tempWwly = text[5:] wwlyRecord = wwlyRecord + "&lt;/br&gt;" + tempWwly else: result = result + "&lt;/br&gt;" + text # print(result) # print(request.url) htmlStr = """ &lt;h3&gt;Record&lt;/h3&gt; &lt;div style="width: 200; float: left;"&gt; &lt;h4&gt;shock:&lt;/h4&gt; &lt;p style="font-size: 6px;"&gt;%s&lt;/p&gt; &lt;/div&gt; &lt;div style="width: 200; float: left;"&gt; &lt;h4&gt;wwly:&lt;/h4&gt; &lt;p style="font-size: 6px;"&gt;%s&lt;/p&gt; &lt;/div&gt; &lt;div style="width: 200; float: left;"&gt; &lt;h4&gt;未知:&lt;/h4&gt; &lt;p style="font-size: 6px;"&gt;%s&lt;/p&gt; &lt;/div&gt; """ % (shockRecord, wwlyRecord, result) # htmlStr = htmlStr + '' return web.Response(body=htmlStr.encode('utf-8'), content_type='text/html')@asyncio.coroutinedef init(loop): app = web.Application(loop=loop) app.router.add_route('GET', '/&#123;anything&#125;', index) app.router.add_route('GET', '/*', index) srv = yield from loop.create_server(app.make_handler(), '0.0.0.0', 9000) logging.info('server started at http://0.0.0.0:9000...') return srvloop = asyncio.get_event_loop()loop.run_until_complete(init(loop))loop.run_forever() 上面的代码实现了解析对方的GET请求, 可以把想传递的内容放在url链接后面, 同时会把内容记录在全局变量中并展示出来. 其中:app.router.add_route(&#39;GET&#39;, &#39;/{anything}&#39;, index)为了把所有的url映射到同一个index函数上. app.make_handler(), &#39;0.0.0.0&#39;, 9000一开始我绑定的本地ip地址127.0.0.1, 发现本机可以访问, 但是外网不能通过本机ip进行访问. 后来尝试绑定0.0.0.0, 实现了外网通过ip地址访问本地python服务器. web.Response(body=htmlStr.encode(&#39;utf-8&#39;), content_type=&#39;text/html&#39;)text/html为了设置响应体格式, 否则对方一访问ip地址就会下载文件.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[搭建hexo博客]]></title>
      <url>%2F2016%2F11%2F21%2Finit%20hexo%2F</url>
      <content type="text"><![CDATA[搭建hexo博客在之前就萌生了建立博客网站的念头, 之前使用WordPress在新浪云上搭建过一次, 但是效果并不理想. 后来意外发现hexo静态博客工具, 又了解到next这个hexo主题, 于是便再一次在github上搭建了此博客. 由于之前搭建过几次, 所以这次搭建的很顺利, 按照文档修改成自己喜欢的样式. 这次我把源码单独作为一个仓库上传至github, 以免有失. 谨记: 当你在嘲笑一亿是一个小目标时, 你是在嘲笑谁?]]></content>
    </entry>

    
  
  
</search>
